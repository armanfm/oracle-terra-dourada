# Deterministic Verifiable Compute via Bare-Metal RISC-V

## Overview

This project demonstrates **deterministic and verifiable computation** executed directly on **bare-metal RISC-V**, compiled from Rust without an operating system, runtime, scheduler, or external dependencies.

The goal is not performance benchmarking or probabilistic inference, but **execution integrity**: ensuring that a computation can be **identified, replayed, and verified** as a factual event.

---

## What Problem This Solves

Modern blockchain and distributed systems validate state transitions, but often **do not verify the integrity of off-chain computation**. Existing approaches rely on:

- trusted oracles  
- probabilistic proofs  
- complex zero-knowledge systems  
- heavyweight virtual machines  

This project addresses a more fundamental question:

> **How can computation itself become a verifiable fact, independent of trust in the executor?**

---

## Core Idea

The system binds computation integrity to a **deterministic execution artifact**:

- A **RISC-V bare-metal ELF**
- Fully deterministic execution
- Explicitly defined input, output, and memory semantics
- Identity derived from the binary hash

Verification is achieved by **replay**, not by trust or probabilistic proof.

---

## Execution Model

### 1. Bare-Metal Environment

The executor is compiled with:

- `#![no_std]`
- `#![no_main]`

Guarantees:

- No operating system
- No libc
- No heap allocation
- No scheduler
- No interrupts
- No background processes

This eliminates common sources of nondeterminism.

---

### 2. Deterministic Computation

The computation:

- Uses frozen coefficients
- Uses a fixed input
- Performs pure arithmetic
- Produces a single deterministic output

Given the same binary and input, the execution path and output are **identical** across runs.

---

### 3. Explicit Output Semantics

The program writes its result to a **fixed memory address**:

- Address: `0x80001000`
- Type: `u64`
- Endianness: little-endian

For the provided input, the expected output is:

- Decimal: `840`
- Hexadecimal: `0x0000000000000348`

This output constitutes the **verifiable state** of the computation.

---

## Artifact Identity

The computation is identified by the hash of its ELF binary:

