use mimalloc::MiMalloc;
#[global_allocator]
static GLOBAL: MiMalloc = MiMalloc;

use warp::Filter;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;
use rand::rngs::StdRng;
use rand::SeedableRng;
use anyhow::{Result, anyhow};
use reqwest::Client;

use halo2_proofs::arithmetic::Field;
use halo2_proofs::{
    dev::MockProver,
    plonk::{create_proof, keygen_pk, keygen_vk, ProvingKey, VerifyingKey},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};
use halo2curves::pasta::{pallas::Base as Fp, vesta::Affine as EqAffine};
use halo2curves::ff::PrimeField;
use base64::{engine::general_purpose, Engine as _};

use halo2_minimal::MyCircuit;

// ---------------- Config ----------------
const ROBOT_VERIFY:  &str = "http://127.0.0.1:5005/verify";
const PROVER_BIND_ADDR: &str = "127.0.0.1:8081";

// ---------------- Tipos ----------------
#[derive(Debug)]
struct ProverError(String);
impl warp::reject::Reject for ProverError {}

#[derive(Deserialize)]
struct HashRequest {
    fp_bytes: Vec<u8>,
    hmac: String,
}

#[derive(Serialize)]
struct ProofResponse {
    success: bool,
    proof_b64: Option<String>,
    y_b64: Option<String>,
    hmac: Option<String>,
    message: Option<String>,
}

// ---------------- Estado ----------------
#[derive(Clone)]
struct ProverState {
    params: Params<EqAffine>,
    vk: Arc<VerifyingKey<EqAffine>>,
    pk: Arc<ProvingKey<EqAffine>>,
    client: Client,
}

impl ProverState {
    fn new(params: Params<EqAffine>, vk: VerifyingKey<EqAffine>, pk: ProvingKey<EqAffine>) -> Self {
        Self {
            params,
            vk: Arc::new(vk),
            pk: Arc::new(pk),
            client: Client::new(),
        }
    }
}

// ------------ Helpers -----------
fn bytes_to_fp(arr: &[u8]) -> Result<Fp> {
    if arr.len() != 32 {
        return Err(anyhow!("fp_bytes deve ter 32 bytes, veio {}", arr.len()));
    }
    let mut a = [0u8; 32];
    a.copy_from_slice(arr);
    Fp::from_repr(a)
        .into_option()
        .ok_or_else(|| anyhow!("bytes nÃ£o representam Fp vÃ¡lido"))
}

// ---------------- Handler ----------------
async fn handle_prove(
    body: HashRequest,
    state: Arc<Mutex<ProverState>>,
) -> std::result::Result<impl warp::Reply, warp::Rejection> {

    println!(
        "âž¡ï¸ [/prove] request recebida | fp_bytes_len={} | hmac={}",
        body.fp_bytes.len(),
        body.hmac
    );

    let guard = state.lock().await;

    // 1) Converter Fp
    let x_fp = bytes_to_fp(&body.fp_bytes)
        .map_err(|e| warp::reject::custom(ProverError(format!("bytes->Fp: {}", e))))?;
    let y_fp = x_fp + x_fp;

    // 2) MockProver (debug)
    let circuit = MyCircuit { x: Some(x_fp), y: Some(y_fp) };
    let prover = MockProver::run(8, &circuit, vec![vec![y_fp]]).unwrap();
    prover.verify().unwrap();

    // 3) Criar prova real
    let mut proof_bytes: Vec<u8> = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EqAffine>>::init(&mut proof_bytes);
    let mut rng = StdRng::from_entropy();
    let instances: &[&[&[Fp]]] = &[&[&[y_fp]]];

    create_proof(&guard.params, &guard.pk, &[circuit], instances, &mut rng, &mut transcript)
        .map_err(|e| warp::reject::custom(ProverError(format!("create_proof: {:?}", e))))?;
    transcript.finalize();

    let proof_b64 = general_purpose::STANDARD.encode(&proof_bytes);
    let y_b64 = general_purpose::STANDARD.encode(y_fp.to_repr());

    // -------------------------------
    // ðŸ”¥ Enviar prova ao Verifier
    // -------------------------------
    let robo_payload = serde_json::json!({
        "proof": proof_bytes,
        "public_inputs": vec![y_fp.to_repr().to_vec()],
    });

    let resp = guard.client
        .post(ROBOT_VERIFY)
        .json(&robo_payload)
        .send()
        .await;

    let resp = match resp {
        Ok(r) => r,
        Err(_) => {
            return Ok(warp::reply::json(&ProofResponse {
                success: false,
                proof_b64: None,
                y_b64: None,
                hmac: None,
                message: Some("Falha ao contactar verifier".into()),
            }));
        }
    };

    let json = resp.json::<serde_json::Value>().await.unwrap_or_default();
    let success_robot = json["success"].as_bool().unwrap_or(false);

    if !success_robot {
        return Ok(warp::reply::json(&ProofResponse {
            success: false,
            proof_b64: None,
            y_b64: None,
            hmac: Some(body.hmac),
            message: Some("Prova invÃ¡lida no verifier".into()),
        }));
    }

    // -------------------------------
    // ðŸŸ¢ Sucesso â€” devolver ao backend
    // -------------------------------
    Ok(warp::reply::json(&ProofResponse {
        success: true,
        proof_b64: Some(proof_b64),
        y_b64: Some(y_b64),
        hmac: Some(body.hmac),
        message: None,
    }))
}

// ---------------- Startup ----------------
#[tokio::main]
async fn main() -> Result<()> {
    println!("ðŸ”‘ [Prover] Inicializando...");

    let params = Params::<EqAffine>::new(8);
    let dummy = MyCircuit { x: None, y: None };

    let vk = keygen_vk(&params, &dummy)?;
    let pk = keygen_pk(&params, vk, &dummy)?;

    let state = Arc::new(Mutex::new(ProverState::new(params, vk, pk)));
    let state_filter = warp::any().map(move || state.clone());

    let prove_route = warp::path("prove")
        .and(warp::post())
        .and(warp::body::json::<HashRequest>())
        .and(state_filter)
        .and_then(handle_prove);

    println!("ðŸš€ [Prover] Rodando http://{PROVER_BIND_ADDR}");
    warp::serve(prove_route).run(([127, 0, 0, 1], 8081)).await;

    Ok(())
}
